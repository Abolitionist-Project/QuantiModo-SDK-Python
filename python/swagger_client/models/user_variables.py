# coding: utf-8

"""
    QuantiModo

    QuantiModo makes it easy to retrieve normalized user data from a wide array of devices and applications. [Learn about QuantiModo](https://quantimo.do), check out our [docs](https://github.com/QuantiModo/docs) or contact us at [help.quantimo.do](https://help.quantimo.do). 

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from pprint import pformat
from six import iteritems
import re


class UserVariables(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self, user=None, variable_id=None, duration_of_action=None, filling_value=None, join_with=None, maximum_allowed_value=None, minimum_allowed_value=None, onset_delay=None, experiment_start_time=None, experiment_end_time=None, alias=None):
        """
        UserVariables - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'user': 'int',
            'variable_id': 'int',
            'duration_of_action': 'int',
            'filling_value': 'int',
            'join_with': 'str',
            'maximum_allowed_value': 'float',
            'minimum_allowed_value': 'float',
            'onset_delay': 'int',
            'experiment_start_time': 'str',
            'experiment_end_time': 'str',
            'alias': 'str'
        }

        self.attribute_map = {
            'user': 'user',
            'variable_id': 'variableId',
            'duration_of_action': 'durationOfAction',
            'filling_value': 'fillingValue',
            'join_with': 'joinWith',
            'maximum_allowed_value': 'maximumAllowedValue',
            'minimum_allowed_value': 'minimumAllowedValue',
            'onset_delay': 'onsetDelay',
            'experiment_start_time': 'experimentStartTime',
            'experiment_end_time': 'experimentEndTime',
            'alias': 'alias'
        }

        self._user = user
        self._variable_id = variable_id
        self._duration_of_action = duration_of_action
        self._filling_value = filling_value
        self._join_with = join_with
        self._maximum_allowed_value = maximum_allowed_value
        self._minimum_allowed_value = minimum_allowed_value
        self._onset_delay = onset_delay
        self._experiment_start_time = experiment_start_time
        self._experiment_end_time = experiment_end_time
        self._alias = alias


    @property
    def user(self):
        """
        Gets the user of this UserVariables.
        User ID

        :return: The user of this UserVariables.
        :rtype: int
        """
        return self._user

    @user.setter
    def user(self, user):
        """
        Sets the user of this UserVariables.
        User ID

        :param user: The user of this UserVariables.
        :type: int
        """
        if user is None:
            raise ValueError("Invalid value for `user`, must not be `None`")

        self._user = user

    @property
    def variable_id(self):
        """
        Gets the variable_id of this UserVariables.
        Common variable id

        :return: The variable_id of this UserVariables.
        :rtype: int
        """
        return self._variable_id

    @variable_id.setter
    def variable_id(self, variable_id):
        """
        Sets the variable_id of this UserVariables.
        Common variable id

        :param variable_id: The variable_id of this UserVariables.
        :type: int
        """
        if variable_id is None:
            raise ValueError("Invalid value for `variable_id`, must not be `None`")

        self._variable_id = variable_id

    @property
    def duration_of_action(self):
        """
        Gets the duration_of_action of this UserVariables.
        The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.

        :return: The duration_of_action of this UserVariables.
        :rtype: int
        """
        return self._duration_of_action

    @duration_of_action.setter
    def duration_of_action(self, duration_of_action):
        """
        Sets the duration_of_action of this UserVariables.
        The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.

        :param duration_of_action: The duration_of_action of this UserVariables.
        :type: int
        """

        self._duration_of_action = duration_of_action

    @property
    def filling_value(self):
        """
        Gets the filling_value of this UserVariables.
        When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing.

        :return: The filling_value of this UserVariables.
        :rtype: int
        """
        return self._filling_value

    @filling_value.setter
    def filling_value(self, filling_value):
        """
        Sets the filling_value of this UserVariables.
        When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing.

        :param filling_value: The filling_value of this UserVariables.
        :type: int
        """

        self._filling_value = filling_value

    @property
    def join_with(self):
        """
        Gets the join_with of this UserVariables.
        joinWith

        :return: The join_with of this UserVariables.
        :rtype: str
        """
        return self._join_with

    @join_with.setter
    def join_with(self, join_with):
        """
        Sets the join_with of this UserVariables.
        joinWith

        :param join_with: The join_with of this UserVariables.
        :type: str
        """

        self._join_with = join_with

    @property
    def maximum_allowed_value(self):
        """
        Gets the maximum_allowed_value of this UserVariables.
        The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis.

        :return: The maximum_allowed_value of this UserVariables.
        :rtype: float
        """
        return self._maximum_allowed_value

    @maximum_allowed_value.setter
    def maximum_allowed_value(self, maximum_allowed_value):
        """
        Sets the maximum_allowed_value of this UserVariables.
        The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis.

        :param maximum_allowed_value: The maximum_allowed_value of this UserVariables.
        :type: float
        """

        self._maximum_allowed_value = maximum_allowed_value

    @property
    def minimum_allowed_value(self):
        """
        Gets the minimum_allowed_value of this UserVariables.
        The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis.

        :return: The minimum_allowed_value of this UserVariables.
        :rtype: float
        """
        return self._minimum_allowed_value

    @minimum_allowed_value.setter
    def minimum_allowed_value(self, minimum_allowed_value):
        """
        Sets the minimum_allowed_value of this UserVariables.
        The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis.

        :param minimum_allowed_value: The minimum_allowed_value of this UserVariables.
        :type: float
        """

        self._minimum_allowed_value = minimum_allowed_value

    @property
    def onset_delay(self):
        """
        Gets the onset_delay of this UserVariables.
        onsetDelay

        :return: The onset_delay of this UserVariables.
        :rtype: int
        """
        return self._onset_delay

    @onset_delay.setter
    def onset_delay(self, onset_delay):
        """
        Sets the onset_delay of this UserVariables.
        onsetDelay

        :param onset_delay: The onset_delay of this UserVariables.
        :type: int
        """

        self._onset_delay = onset_delay

    @property
    def experiment_start_time(self):
        """
        Gets the experiment_start_time of this UserVariables.
        Earliest measurement startTime that should be used in analysis. For instance, the date when you started tracking something.  Helpful in determining when to start 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.  Uses ISO string format

        :return: The experiment_start_time of this UserVariables.
        :rtype: str
        """
        return self._experiment_start_time

    @experiment_start_time.setter
    def experiment_start_time(self, experiment_start_time):
        """
        Sets the experiment_start_time of this UserVariables.
        Earliest measurement startTime that should be used in analysis. For instance, the date when you started tracking something.  Helpful in determining when to start 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.  Uses ISO string format

        :param experiment_start_time: The experiment_start_time of this UserVariables.
        :type: str
        """

        self._experiment_start_time = experiment_start_time

    @property
    def experiment_end_time(self):
        """
        Gets the experiment_end_time of this UserVariables.
        Latest measurement startTime that should be used in analysis. For instance, the date when you stopped tracking something.  Helpful in determining when to stop 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.   Uses ISO string format

        :return: The experiment_end_time of this UserVariables.
        :rtype: str
        """
        return self._experiment_end_time

    @experiment_end_time.setter
    def experiment_end_time(self, experiment_end_time):
        """
        Sets the experiment_end_time of this UserVariables.
        Latest measurement startTime that should be used in analysis. For instance, the date when you stopped tracking something.  Helpful in determining when to stop 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.   Uses ISO string format

        :param experiment_end_time: The experiment_end_time of this UserVariables.
        :type: str
        """

        self._experiment_end_time = experiment_end_time

    @property
    def alias(self):
        """
        Gets the alias of this UserVariables.
        User-defined display alias for variable name

        :return: The alias of this UserVariables.
        :rtype: str
        """
        return self._alias

    @alias.setter
    def alias(self, alias):
        """
        Sets the alias of this UserVariables.
        User-defined display alias for variable name

        :param alias: The alias of this UserVariables.
        :type: str
        """

        self._alias = alias

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
