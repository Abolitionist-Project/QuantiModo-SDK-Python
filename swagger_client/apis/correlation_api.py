# coding: utf-8

"""
CorrelationApi.py
Copyright 2016 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class CorrelationApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def correlations_get(self, **kwargs):
        """
        Get all Correlations
        Get all Correlations

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.correlations_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str access_token: User's OAuth2 access token
        :param int timestamp: Time at which correlation was calculated
        :param int user_id: ID of user that owns this correlation
        :param float correlation: Pearson correlation coefficient between cause and effect measurements
        :param int cause_id: variable ID of the predictor variable for which the user desires correlations
        :param int effect_id: variable ID of the outcome variable for which the user desires correlations
        :param int onset_delay: User estimated or default time after cause measurement before a perceivable effect is observed
        :param int duration_of_action: Time over which the cause is expected to produce a perceivable effect following the onset delay
        :param int number_of_pairs: Number of points that went into the correlation calculation
        :param float value_predicting_high_outcome: cause value that predicts an above average effect value (in default unit for predictor variable)
        :param float value_predicting_low_outcome: cause value that predicts a below average effect value (in default unit for predictor variable)
        :param float optimal_pearson_product: Optimal Pearson Product
        :param float vote: Vote
        :param float statistical_significance: A function of the effect size and sample size
        :param str cause_unit: Unit of the predictor variable
        :param int cause_unit_id: Unit ID of the predictor variable
        :param int cause_changes: Cause changes
        :param int effect_changes: Effect changes
        :param float qm_score: QM Score
        :param str error: error
        :param str created_at: When the record was first created. Use ISO 8601 datetime format
        :param str updated_at: When the record in the database was last updated. Use ISO 8601 datetime format
        :param float reverse_pearson_correlation_coefficient: Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
        :param float predictive_pearson_correlation_coefficient: Predictive Pearson Correlation Coefficient
        :param int limit: Limit the number of results returned
        :param int offset: Records from give Offset
        :param str sort: Sort records by given field
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_token', 'timestamp', 'user_id', 'correlation', 'cause_id', 'effect_id', 'onset_delay', 'duration_of_action', 'number_of_pairs', 'value_predicting_high_outcome', 'value_predicting_low_outcome', 'optimal_pearson_product', 'vote', 'statistical_significance', 'cause_unit', 'cause_unit_id', 'cause_changes', 'effect_changes', 'qm_score', 'error', 'created_at', 'updated_at', 'reverse_pearson_correlation_coefficient', 'predictive_pearson_correlation_coefficient', 'limit', 'offset', 'sort']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method correlations_get" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/correlations'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']
        if 'timestamp' in params:
            query_params['timestamp'] = params['timestamp']
        if 'user_id' in params:
            query_params['user_id'] = params['user_id']
        if 'correlation' in params:
            query_params['correlation'] = params['correlation']
        if 'cause_id' in params:
            query_params['cause_id'] = params['cause_id']
        if 'effect_id' in params:
            query_params['effect_id'] = params['effect_id']
        if 'onset_delay' in params:
            query_params['onset_delay'] = params['onset_delay']
        if 'duration_of_action' in params:
            query_params['duration_of_action'] = params['duration_of_action']
        if 'number_of_pairs' in params:
            query_params['number_of_pairs'] = params['number_of_pairs']
        if 'value_predicting_high_outcome' in params:
            query_params['value_predicting_high_outcome'] = params['value_predicting_high_outcome']
        if 'value_predicting_low_outcome' in params:
            query_params['value_predicting_low_outcome'] = params['value_predicting_low_outcome']
        if 'optimal_pearson_product' in params:
            query_params['optimal_pearson_product'] = params['optimal_pearson_product']
        if 'vote' in params:
            query_params['vote'] = params['vote']
        if 'statistical_significance' in params:
            query_params['statistical_significance'] = params['statistical_significance']
        if 'cause_unit' in params:
            query_params['cause_unit'] = params['cause_unit']
        if 'cause_unit_id' in params:
            query_params['cause_unit_id'] = params['cause_unit_id']
        if 'cause_changes' in params:
            query_params['cause_changes'] = params['cause_changes']
        if 'effect_changes' in params:
            query_params['effect_changes'] = params['effect_changes']
        if 'qm_score' in params:
            query_params['qm_score'] = params['qm_score']
        if 'error' in params:
            query_params['error'] = params['error']
        if 'created_at' in params:
            query_params['created_at'] = params['created_at']
        if 'updated_at' in params:
            query_params['updated_at'] = params['updated_at']
        if 'reverse_pearson_correlation_coefficient' in params:
            query_params['reverse_pearson_correlation_coefficient'] = params['reverse_pearson_correlation_coefficient']
        if 'predictive_pearson_correlation_coefficient' in params:
            query_params['predictive_pearson_correlation_coefficient'] = params['predictive_pearson_correlation_coefficient']
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'sort' in params:
            query_params['sort'] = params['sort']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse20017',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def correlations_post(self, **kwargs):
        """
        Store Correlation
        Store Correlation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.correlations_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str access_token: User's OAuth2 access token
        :param Correlation body: Correlation that should be stored
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_token', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method correlations_post" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/correlations'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse20018',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def correlations_id_get(self, id, **kwargs):
        """
        Get Correlation Details
        Get Correlation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.correlations_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of Correlation (required)
        :param str access_token: User's OAuth2 access token
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method correlations_id_get" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `correlations_id_get`")

        resource_path = '/correlations/{id}'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse20018',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def correlations_id_put(self, id, **kwargs):
        """
        Update Correlation
        Update Correlation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.correlations_id_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of Correlation (required)
        :param str access_token: User's OAuth2 access token
        :param Correlation body: Correlation that should be updated
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method correlations_id_put" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `correlations_id_put`")

        resource_path = '/correlations/{id}'.replace('{format}', 'json')
        method = 'PUT'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2002',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def correlations_id_delete(self, id, **kwargs):
        """
        Delete Correlation
        Delete Correlation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.correlations_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of Correlation (required)
        :param str access_token: User's OAuth2 access token
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method correlations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `correlations_id_delete`")

        resource_path = '/correlations/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2002',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response
