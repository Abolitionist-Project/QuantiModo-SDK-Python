# coding: utf-8

"""
AggregatedCorrelationApi.py
Copyright 2016 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class AggregatedCorrelationApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def aggregated_correlations_get(self, **kwargs):
        """
        Get all AggregatedCorrelations
        Get all AggregatedCorrelations

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregated_correlations_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str access_token: User's OAuth2 access token
        :param float correlation: Pearson correlation coefficient between cause and effect measurements
        :param int cause_id: Variable ID of the predictor variable for which the user desires correlations
        :param int effect_id: Variable ID of the outcome variable for which the user desires correlations
        :param int onset_delay: User estimated (or default number of seconds) after cause measurement before a perceivable effect is observed
        :param int duration_of_action: Number of seconds over which the predictor variable event is expected to produce a perceivable effect following the onset delay
        :param int number_of_pairs: Number of predictor/outcome data points used in the analysis
        :param float value_predicting_high_outcome: Predictor daily aggregated measurement value that predicts an above average effect measurement value (in default unit for predictor variable)
        :param float value_predicting_low_outcome: Predictor daily aggregated measurement value that predicts a below average effect measurement value (in default unit for outcome variable)
        :param float optimal_pearson_product: Optimal Pearson Product
        :param int number_of_users: Number of users whose data was used in this aggregation
        :param int number_of_correlations: Number of correlational analyses used in this aggregation
        :param float statistical_significance: A function of the effect size and sample size
        :param str cause_unit: Abbreviated unit name for the predictor variable
        :param int cause_unit_id: Unit ID for the predictor variable
        :param int cause_changes: Number of times that the predictor time series changes
        :param int effect_changes: Number of times that the predictor time series changes
        :param float aggregate_qm_score: Aggregated QM Score which is directly proportional with the relevance of each predictor or outcome
        :param str created_at: Date at which the analysis was first performed
        :param str updated_at: Date at which the analysis was last updated
        :param str status: Indicates whether an analysis is up to date (UPDATED), needs to be updated (WAITING), or had an error (ERROR)
        :param str error_message: Message describing any problems encountered during the analysis
        :param str last_successful_update_time: Last Successful update time
        :param float reverse_pearson_correlation_coefficient: Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
        :param float predictive_pearson_correlation_coefficient: Predictive Pearson Correlation Coefficient
        :param int limit: Limit the number of results returned
        :param int offset: Records from give Offset
        :param str sort: Sort records by given field
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_token', 'correlation', 'cause_id', 'effect_id', 'onset_delay', 'duration_of_action', 'number_of_pairs', 'value_predicting_high_outcome', 'value_predicting_low_outcome', 'optimal_pearson_product', 'number_of_users', 'number_of_correlations', 'statistical_significance', 'cause_unit', 'cause_unit_id', 'cause_changes', 'effect_changes', 'aggregate_qm_score', 'created_at', 'updated_at', 'status', 'error_message', 'last_successful_update_time', 'reverse_pearson_correlation_coefficient', 'predictive_pearson_correlation_coefficient', 'limit', 'offset', 'sort']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregated_correlations_get" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/aggregatedCorrelations'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']
        if 'correlation' in params:
            query_params['correlation'] = params['correlation']
        if 'cause_id' in params:
            query_params['cause_id'] = params['cause_id']
        if 'effect_id' in params:
            query_params['effect_id'] = params['effect_id']
        if 'onset_delay' in params:
            query_params['onset_delay'] = params['onset_delay']
        if 'duration_of_action' in params:
            query_params['duration_of_action'] = params['duration_of_action']
        if 'number_of_pairs' in params:
            query_params['number_of_pairs'] = params['number_of_pairs']
        if 'value_predicting_high_outcome' in params:
            query_params['value_predicting_high_outcome'] = params['value_predicting_high_outcome']
        if 'value_predicting_low_outcome' in params:
            query_params['value_predicting_low_outcome'] = params['value_predicting_low_outcome']
        if 'optimal_pearson_product' in params:
            query_params['optimal_pearson_product'] = params['optimal_pearson_product']
        if 'number_of_users' in params:
            query_params['number_of_users'] = params['number_of_users']
        if 'number_of_correlations' in params:
            query_params['number_of_correlations'] = params['number_of_correlations']
        if 'statistical_significance' in params:
            query_params['statistical_significance'] = params['statistical_significance']
        if 'cause_unit' in params:
            query_params['cause_unit'] = params['cause_unit']
        if 'cause_unit_id' in params:
            query_params['cause_unit_id'] = params['cause_unit_id']
        if 'cause_changes' in params:
            query_params['cause_changes'] = params['cause_changes']
        if 'effect_changes' in params:
            query_params['effect_changes'] = params['effect_changes']
        if 'aggregate_qm_score' in params:
            query_params['aggregate_qm_score'] = params['aggregate_qm_score']
        if 'created_at' in params:
            query_params['created_at'] = params['created_at']
        if 'updated_at' in params:
            query_params['updated_at'] = params['updated_at']
        if 'status' in params:
            query_params['status'] = params['status']
        if 'error_message' in params:
            query_params['error_message'] = params['error_message']
        if 'last_successful_update_time' in params:
            query_params['last_successful_update_time'] = params['last_successful_update_time']
        if 'reverse_pearson_correlation_coefficient' in params:
            query_params['reverse_pearson_correlation_coefficient'] = params['reverse_pearson_correlation_coefficient']
        if 'predictive_pearson_correlation_coefficient' in params:
            query_params['predictive_pearson_correlation_coefficient'] = params['predictive_pearson_correlation_coefficient']
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'sort' in params:
            query_params['sort'] = params['sort']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse200',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def aggregated_correlations_post(self, **kwargs):
        """
        Store AggregatedCorrelation
        Store AggregatedCorrelation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregated_correlations_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str access_token: User's OAuth2 access token
        :param AggregatedCorrelation body: AggregatedCorrelation that should be stored
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['access_token', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregated_correlations_post" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/aggregatedCorrelations'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2001',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def aggregated_correlations_id_get(self, id, **kwargs):
        """
        Get AggregatedCorrelation
        Get AggregatedCorrelation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregated_correlations_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of AggregatedCorrelation (required)
        :param str access_token: User's OAuth2 access token
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregated_correlations_id_get" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `aggregated_correlations_id_get`")

        resource_path = '/aggregatedCorrelations/{id}'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2001',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def aggregated_correlations_id_put(self, id, **kwargs):
        """
        Update AggregatedCorrelation
        Update AggregatedCorrelation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregated_correlations_id_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of AggregatedCorrelation (required)
        :param str access_token: User's OAuth2 access token
        :param AggregatedCorrelation body: AggregatedCorrelation that should be updated
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregated_correlations_id_put" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `aggregated_correlations_id_put`")

        resource_path = '/aggregatedCorrelations/{id}'.replace('{format}', 'json')
        method = 'PUT'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2002',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def aggregated_correlations_id_delete(self, id, **kwargs):
        """
        Delete AggregatedCorrelation
        Delete AggregatedCorrelation

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.aggregated_correlations_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id of AggregatedCorrelation (required)
        :param str access_token: User's OAuth2 access token
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'access_token']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregated_correlations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `aggregated_correlations_id_delete`")

        resource_path = '/aggregatedCorrelations/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'access_token' in params:
            query_params['access_token'] = params['access_token']

        header_params = {}

        form_params = []
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['quantimodo_oauth2']

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='InlineResponse2002',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response
